Index: Task1/task1.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom numpy.polynomial import Polynomial\r\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\r\nimport tkinter as tk\r\n\r\nfrom Task1.Sin_Cos.comparesignals import SignalSamplesAreEqual\r\n\r\n\r\nclass SignalProcessing:\r\n\r\n    def __init__(self):\r\n        # Initialize the display canvas as None\r\n        self.display_canvas = None\r\n    def read_signal_file(self, filename='signal1.txt'):\r\n\r\n        # Read the contents of the file\r\n        with open(filename, 'r') as file:\r\n            lines = file.readlines()\r\n\r\n        # Remove leading/trailing whitespaces and newline characters\r\n        lines = [line.strip() for line in lines]\r\n\r\n        # Read the first three rows into separate variables\r\n        self.signalType = int(lines[0])\r\n        self.isPeriodic = int(lines[1])\r\n        self.N = int(lines[2])\r\n\r\n        # Read the remaining rows into a list of lists\r\n        samples = [list(map(float, line.split(' ')))\r\n                   for line in lines[3:]]\r\n\r\n        self.samples = np.array(samples)\r\n\r\n        # Extract x and y values from the two-value groups\r\n        self.x_values = self.samples[:, 0]\r\n        self.y_values = self.samples[:, 1]\r\n\r\n    def plot_digital(self):\r\n\r\n        # Determine the range of the y-axis\r\n        y_range = max(abs(min(self.y_values))+1, abs(max(self.y_values))+1)\r\n        # Plot the digital signal with red points\r\n        plt.stem(self.x_values, self.y_values, linefmt='-',\r\n                 markerfmt='ro', basefmt=' ')\r\n\r\n        # Draw the x-axis line\r\n        plt.axhline(0, color='black')\r\n\r\n        plt.xlim(min(self.x_values), max(self.x_values) + 1)\r\n        plt.ylim(min(self.y_values) - 1, max(self.y_values) + 1)\r\n\r\n        # Set labels and title\r\n        plt.xlabel('n')\r\n        plt.ylabel('x[n]')\r\n        plt.title('Digital Representation')\r\n\r\n        # Show the plot\r\n        plt.show()\r\n\r\n    def plot_continuous_discrete(self):\r\n        y_range = max(abs(min(self.y_values))+1, abs(max(self.y_values))+1)\r\n\r\n        plt.step(self.x_values, self.y_values, 'b', where='post')\r\n\r\n        plt.axhline(0, color='black')\r\n        plt.xlim(min(self.x_values), max(self.x_values) + 1)\r\n        plt.ylim(min(self.y_values) - 1, max(self.y_values) + 1)\r\n        plt.xlabel('n')\r\n        plt.ylabel('x[n]')\r\n        plt.title('Continuous(t) Discrete(A) Representation')\r\n        plt.grid(True)\r\n        plt.show()\r\n\r\n    def plot_analog(self):\r\n        # Determine the range of the y-axis\r\n        y_range = max(abs(min(self.y_values))+1, abs(max(self.y_values))+1)\r\n\r\n        # Polynomial curve fitting\r\n        degree = 6  # Change the degree based on desired smoothness\r\n        p = Polynomial.fit(self.x_values, self.y_values, degree)\r\n        x_smooth = np.linspace(min(self.x_values), max(self.x_values), 1000)\r\n        y_smooth = p(x_smooth)\r\n        plt.plot(x_smooth, y_smooth, 'b')\r\n        plt.axhline(0, color='black')\r\n        # Set y-axis limits\r\n        plt.xlim(min(x_smooth), max(x_smooth)+1)\r\n        plt.ylim(min(y_smooth)-1, max(y_smooth)+1)\r\n        plt.xlabel('n')\r\n        plt.ylabel('x[n]')\r\n        plt.title('Analog Representation')\r\n        plt.grid(True)\r\n        plt.show()\r\n\r\n    def read_input(self, filename='Sin_Cos/Inputs.txt'):\r\n        with open(filename, \"r\") as file:\r\n            file_content = file.read()\r\n\r\n        self.test_cases = []\r\n        current_test_case = {}\r\n\r\n        lines = file_content.split(\"\\n\")\r\n        for line in lines:\r\n            if line.strip() == \"\":\r\n                if current_test_case:\r\n                    self.test_cases.append(current_test_case)\r\n                    current_test_case = {}\r\n            elif \"=\" in line:\r\n                key, value = line.split(\"=\")\r\n                key = key.strip()\r\n                value = value.strip().strip('\"')  # Remove double quotes if present\r\n                current_test_case[key] = value\r\n\r\n        if current_test_case:\r\n            self.test_cases.append(current_test_case)\r\n\r\n    # Function to display sine or cosine wave\r\n    def display_wave(self, wave_type):\r\n        title = ''\r\n        x = np.linspace(0, 2 * np.pi, 1000)\r\n        y = np.sin(x)\r\n        if wave_type == \"sin\":\r\n            # Calculate the angular frequency (ω) based on the Analog Frequency\r\n            angular_frequency = 2 * np.pi * int(self.test_cases[0]['AnalogFrequency'])\r\n            # Initialize an empty list to store the modeled sine wave and indices\r\n            indicis = range(0, int(self.test_cases[0]['SamplingFrequency']))\r\n            sine_wave = []\r\n            # Loop through the data points\r\n            for i in indicis:\r\n                # Calculate the sine wave at this time point\r\n                sine_value = int(self.test_cases[0]['A']) * np.sin(angular_frequency * i / int(self.test_cases[0]['SamplingFrequency']) + float(self.test_cases[0]['PhaseShift']))\r\n\r\n                # Append the modeled sine value to the list\r\n                sine_wave.append(sine_value)\r\n            # Now, 'sine_wave' contains the modeled sine wave for each data point\r\n            print(indicis)\r\n            print(sine_wave)\r\n            SignalSamplesAreEqual(file_name='Sin_Cos\\SinOutput.txt',indices=indicis,samples=sine_wave)\r\n            y = np.sin(sine_wave)\r\n            title = \"Sinusoidal Signal\"\r\n\r\n        elif wave_type == \"cos\":\r\n            # Calculate the angular frequency (ω) based on the Analog Frequency\r\n            angular_frequency = 2 * np.pi * int(self.test_cases[1]['AnalogFrequency'])\r\n            # Initialize an empty list to store the modeled sine wave and indices\r\n            indicis = range(0, int(self.test_cases[1]['SamplingFrequency']))\r\n            cosine_wave = []\r\n            # Loop through the data points\r\n            for i in indicis:\r\n                # Calculate the sine wave at this time point\r\n                cosine_value = int(self.test_cases[1]['A']) * np.cos(\r\n                    angular_frequency * i / int(self.test_cases[1]['SamplingFrequency']) + float(\r\n                        self.test_cases[1]['PhaseShift']))\r\n\r\n                # Append the modeled sine value to the list\r\n                cosine_wave.append(cosine_value)\r\n            # Now, 'sine_wave' contains the modeled sine wave for each data point\r\n            print(indicis)\r\n            print(cosine_wave)\r\n            SignalSamplesAreEqual(file_name='Sin_Cos\\CosOutput.txt', indices=indicis, samples=cosine_wave)\r\n            y = np.cos(cosine_wave)\r\n            title = \"Cosinusoidal Signal\"\r\n        # If the canvas exists, delete it\r\n        if self.display_canvas:\r\n            self.display_canvas.get_tk_widget().pack_forget()\r\n\r\n        # Create a new figure for the plot\r\n        fig, ax = plt.subplots()\r\n        ax.plot(indicis, y)\r\n        ax.set_title(title)\r\n\r\n        # Embed the plot in the Tkinter window\r\n        self.display_canvas = FigureCanvasTkAgg(fig, master=self.window)\r\n        self.display_canvas.get_tk_widget().pack()\r\n        self.display_canvas.draw()\r\n\r\n    def gui_display(self):\r\n        # Create the main window\r\n        self.window = tk.Tk()\r\n        self.window.title(\"Sine/Cosine Wave Viewer\")\r\n\r\n        # Create a label\r\n        label = tk.Label(self.window, text=\"Select a wave to view:\")\r\n        label.pack()\r\n\r\n        # Create radio buttons for selecting the wave type\r\n        self.wave_var = tk.StringVar()\r\n        self.wave_var.set(\"sin\")  # Default selection\r\n        sine_radio = tk.Radiobutton(\r\n            self.window, text=\"sin\", variable=self.wave_var, value=\"sin\")\r\n        cosine_radio = tk.Radiobutton(\r\n            self.window, text=\"cos\", variable=self.wave_var, value=\"cos\")\r\n        sine_radio.pack()\r\n        cosine_radio.pack()\r\n\r\n        # Create a button to display the selected wave\r\n        display_button = tk.Button(\r\n            self.window, text=\"Display\", command=lambda: self.display_wave(self.wave_var.get()))\r\n        display_button.pack()\r\n\r\n        # Run the main loop\r\n        self.window.mainloop()\r\n\r\n\r\nsignal = SignalProcessing()\r\nsignal.read_signal_file(filename='signal1.txt')\r\n\r\n\r\n# signal.plot_analog()\r\n# signal.plot_digital()\r\n# signal.plot_continuous_discrete()\r\nsignal.read_input()\r\nsignal.gui_display()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Task1/task1.py b/Task1/task1.py
--- a/Task1/task1.py	(revision 874c542edfda047cdb7ccbf7822bb92807b6217a)
+++ b/Task1/task1.py	(date 1697481395113)
@@ -136,7 +136,7 @@
             print(indicis)
             print(sine_wave)
             SignalSamplesAreEqual(file_name='Sin_Cos\SinOutput.txt',indices=indicis,samples=sine_wave)
-            y = np.sin(sine_wave)
+            y = sine_wave
             title = "Sinusoidal Signal"
 
         elif wave_type == "cos":
@@ -158,7 +158,7 @@
             print(indicis)
             print(cosine_wave)
             SignalSamplesAreEqual(file_name='Sin_Cos\CosOutput.txt', indices=indicis, samples=cosine_wave)
-            y = np.cos(cosine_wave)
+            y = cosine_wave
             title = "Cosinusoidal Signal"
         # If the canvas exists, delete it
         if self.display_canvas:
@@ -166,13 +166,13 @@
 
         # Create a new figure for the plot
         fig, ax = plt.subplots()
-        ax.plot(indicis, y)
+        ax.plot(indicis[:10], y[:10])
         ax.set_title(title)
 
         # Embed the plot in the Tkinter window
         self.display_canvas = FigureCanvasTkAgg(fig, master=self.window)
         self.display_canvas.get_tk_widget().pack()
-        self.display_canvas.draw()
+        # self.display_canvas.draw()
 
     def gui_display(self):
         # Create the main window
@@ -206,8 +206,8 @@
 signal.read_signal_file(filename='signal1.txt')
 
 
-# signal.plot_analog()
-# signal.plot_digital()
-# signal.plot_continuous_discrete()
+signal.plot_analog()
+signal.plot_digital()
+signal.plot_continuous_discrete()
 signal.read_input()
 signal.gui_display()
